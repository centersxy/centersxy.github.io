<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS中数据格式的转化]]></title>
    <url>%2F2018%2F04%2F14%2F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[JSON 转 数组格式栗子:{&quot;count&quot;:&quot;4126&quot;,&quot;yuzhi&quot;:&quot;4109&quot;,&quot;donhuan&quot;:&quot;2&quot;,&quot;syslog&quot;:&quot;15&quot;,&quot;device&quot;:&quot;0&quot;} 12345var result = [];for (var i in json) &#123; result.push(json[i])&#125;// [&quot;4126&quot;, &quot;4109&quot;, &quot;2&quot;, &quot;15&quot;, &quot;0&quot;] 12const list = Object.keys(json).map((item, index) =&gt; (&#123;key: item, value:json[item]&#125;))// [&#123;&#125;,&#123;&#125;,&#123;&#125;]]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式和字符操作]]></title>
    <url>%2F2018%2F03%2F14%2FregExp%2F</url>
    <content type="text"><![CDATA[用得到的一些实例 获取最后一个/xx.123456789var reg = /.*\/([^\.\/]+)/g;var url = &quot;sdfsdfsdfsdfsdfsdfsdfsdf/123.jpg&quot;;console.log(str.replace(reg,&quot;$1&quot;))// 123.var str = &quot;/asdasf/asfaewf/agaegr/trer/rhh&quot;;var index = str .lastIndexOf(&quot;\/&quot;); str = str .substring(index + 1, str .length);// rhh 12345var blueurl= 127.0.0.1/1.txtvar reg = /([/][^/]+)$/;var blueurl = blueurl.replace(reg, &quot;&quot;);var reg2 = /([^/]+)$/; var bluef charAt 返回指定位置的字符。12var get_char = a.charAt(0);//get_char = &quot;h&quot; substring 返回字符串的一个子串，传入参数是起始位置和结束位置。1234var sub_string1 = a.substring(1);//sub_string1 = &quot;ello&quot;var sub_string2 = a.substring(1,4);//sub_string2 = &quot;ell&quot; substr 返回字符串的一个子串，传入参数是起始位置和长度 1234var sub_string1 = a.substr(1);//sub_string1 = &quot;ello&quot;var sub_string2 = a.substr(1,4);//sub_string2 = &quot;ello&quot; slice 提取字符串的一部分，并返回一个新字符串（与 substring 相同）。1234var sub_string1 = a.slice(1);//sub_string1 = &quot;ello&quot;var sub_string2 = a.slice(1,4);//sub_string2 = &quot;ell&quot; toLowerCase 将整个字符串转成小写字母。12var lower_string = a.toLowerCase();//lower_string = &quot;hello&quot; toUpperCase 将整个字符串转成大写字母。12var upper_string = a.toUpperCase();//upper_string = &quot;HELLO&quot; es6中的方法repeat方法返回一个新字符串，表示将原字符串重复n次。123&apos;x&apos;.repeat(3) // &quot;xxx&quot;&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;&apos;na&apos;.repeat(0) // &quot;&quot;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中数组的常用方法(包含es6扩展)]]></title>
    <url>%2F2018%2F03%2F14%2FjsArr%2F</url>
    <content type="text"><![CDATA[JS中数组的常用方法(包含es6扩展 1、join()1234功能：将数组中所有元素都转化为字符串并连接在一起。输入： 分隔符，默认为逗号输出：分隔符分割的字符串举例： 123var a = [1,2,3];a.join(); // =&gt;&quot;1,2,3&quot;a.join(&quot;;&quot;);// =&gt;&quot;1;2;3&quot; 2、 reverse()1234功能：将数组中的元素颠倒顺序。输入：无输出：逆序的数组举例： 12var a = [1,2,3];a.reverse.join()// =&gt;&quot;3,2,1&quot; 3、sort() 12345功能：将数组中的元素 输入：比较函数或null。null时表示按照字母表顺序排序；传入带两个参数的比较函数时；第一个参数在前，则返回小于0的数值；第一个参数在后，则返回大于0的数组 输出：排序后数组 注意：改变了原数组 举例： 123456var a = [22,33,11111,4444];a.sort();// =&gt;11111,22,33,4444a.sort(function(a,b)&#123; return a-b;&#125;);// =&gt; 22,33,4444,11111a.sort(function(a,b)&#123;return b-a&#125;)// =&gt;11111,4444,33,22 4、concat() 12345功能：数组拼接的功能 输入：待拼接的元素；如果参数中有数组，则连接的是数组元素，而非数组本身；但是不支持递归，不修改调用的数组。 输出：拼接后的新数组 注意：新建的数组，原数组不改变。 举例： 1234var a = [1,2,3];a.concat(4,5) // =&gt;[1,2,3,4,5]a.concat([4,5]) // =&gt;[1,2,3,4,5]a.concat(4,[5,[6,7]]) //[1,2,3,4,5,[6,7]] 5、slice() 12345功能：获取原数组的片段或子数组 输入：片段的开始和结束 输出：返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定位置之间的所有元素。如果为负数，表示相对于数组中最后一个元素的位置。 注意：新建的数组，原数组不改变。 举例： 1234var a = [1,2,3,4,5];a.slice(0,3);// =&gt;[1,2,3]a.slice(3);// =&gt;[4,5]a.slice(1,-1)// =&gt;[2,3,4] 6、splice() 12345功能：从数组中删除元素、插入元素到数组中或者同事完成这两种操作。 输入：第一个参数为指定插入或删除的起始位置，第二个参数为要删除的个数。之后的参数表示需要插入到数组中的元素 输出：返回一个由删除元素组成的数组。 注意：新建了一个数组，并修改了原数组 举例： 123var a = [1,2,3,4,5,6,7,8];a.splice(4) // =&gt;[5,6,7,8];a [1,2,3,4]a.splice(2,0,&apos;a&apos;,&apos;b&apos;) // =&gt;[];a [1,2,a,b,3,4] 7、push()和pop() 1234功能：push从数组尾部添加一个或多个元素，并返回数组新的长度；pop返回最后一个元素 输入：push输入为插入的元素；pop输入为空 输出：push为新长度；pop为返回的数组元素 举例： 123var stack = [];stack.push(1,2);// =&gt;stack:[1,2],返回2stack.pop;// =&gt; stack: [1],返回2 8、unshift()和shift 功能：类似push和pop，不同是从头部插入和删除，而非尾部 9、toString()和toLocaleString() 1234功能：将数组的每个元素转化为字符串，并且输入用逗号分隔的字符串列表。功能类似join(); 输入：无 输出：字符串 举例： 1[1,2,3].toString() // =&gt;&apos;1,2,3&apos; ###以下为es6中新增的9个方法 10、forEach() 1234功能：从头至尾遍历数组，为每个元素调用指定函数 输入：输入为一个待遍历函数，函数的参数依次为：数组元素、元素的索引、数组本身 输出：只是执行了遍历函数，无特定返回 举例： 123var data = [1,2,3,4,5];data.forEach(function(v,i,a)&#123;a[i] = v + 1;&#125;);data // =&gt;[2,3,4,5,6] 11、map() 12345功能：调用的数组的每一个元素传递给指定的函数，并返回一个新数组 输入：和forEach一样 输出：执行完函数的新数组 注意：返回新数组，不修改原数组 举例： 12a = [1,2,3];b = a.map(function(x)&#123;return x*x;&#125;); // =&gt;[1,4,9] 12、filter() 1234功能：将数组元素执行特定函数，而返回一个子集。 输入：执行逻辑判断的函数，该函数返回true或false，参数类似forEach和map() 输出：如果执行输入函数返回值为true，则传递给判定函数的元素是这个子集的成员 举例： 12a = [5,4,3,2,1];smallvalues = a.filter(function(x)&#123;return x&lt;3&#125;);// =&gt;[2,1] 13、every()和some() 1234功能：对数组元素进行指定函数的逻辑判断。 输入：特定函数 输出：true 或者false 举例： 12var a = [1,2,3,4,5];a.every(function(x)&#123;return x&lt;10;&#125;) // =&gt;true 14、reduce()和reduceRight() 123功能：使用指定的函数将数组元素进行组合，生成单个值。 输入：两个参数，第一个是执行化简操作的函数。第二个（可选）的参数是一个传递给函数的初始值。 注意：执行化简的函数的第一个参数为目前为止化简操作累积的结果。 15、indexOf()和lastIndexOf() 123功能：搜索整个数组中具有给定值得元素，返回找到的第一个元素的索引或者如果没有找到就返回-1.lastIndexOf为反向搜索。 输入：元素的值。 输入：索引值 es6扩展16、Array.from() 1234功能：将两类对象转为真正的数组：类似数组的对象和可遍历的对象 输入：待转换的对象，第二个参数可选，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 输入：数组 举例： 1234567let arrayLike = &#123; &apos;0&apos;:&apos;a&apos;, &apos;1&apos;:&apos;b&apos;, &apos;2&apos;:&apos;c&apos;, length:3&#125;;let arr2 = Array.from(arrayLike);// =&gt;[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] 17、Array.of() 1234功能：将一组值，转换为数组。 输入：数组元素 输出：数组 举例： 12Array.of(2,11,3)// =&gt;[2,11,3]Array.of(3)// =&gt;[3] 18、copyWithin() 12345功能：在当前数组内部，将指定位置的成员复制到其他位置，返回当前数组。 输入：第一个参数（从该位置开始替换数据）；第二个参数可选（从该位置开始读取数据，默认为0，负值表示倒数）；第三个参数（到该位置前停止读取，默认为数组长度） 输出：返回当前替换后的数组。 注意：改变了当前数组 举例： 1[1, 2, 3, 4, 5].copyWithin(0, 3) //=&gt; [4, 5, 3, 4, 5] 19、find()和findIndex() 1234功能：找到第一个符合条件的数组成员。 输入：回调函数，所有数组成员依次执行该函数，直到找到第一个返回值为true的成员。回调函数可以接受三个参数，依次为值，位置，原数组。 输出：find()返回找到的成员；findIndex()返回成员的位置。 举例： 123[1,5,10,15].find(function(value,index,arr)&#123; return value &gt; 9;&#125;)// =&gt;10 20、fill() 1234功能：使用给定的值，填充一个数组。 输入：第一个参数为待填充的值，第二和第三参数可选，分别表示填充的起始和结束位置(不包括)。 输出：填充后的数组 举例： 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// =&gt;[&apos;a&apos;, 7, &apos;c&apos;] 21、entries()、keys()、values() 1234功能：用于遍历数组，可以用for…of循环进行遍历。区别是keys()是对键名的遍历、values是对键值的遍历、entries()是对键值对的遍历。 输入：无 输出：遍历器对象 举例： 1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// =&gt;0// =&gt;1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// =&gt;&apos;a&apos;// =&gt;&apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// =&gt;0 &quot;a&quot;// =&gt;1 &quot;b&quot; 22、includes() 12345功能：表示某个数组是否包含给定的值 输入：第一个参数必选（待检查的给定值），第二个参数可选，表示搜索的起始位置，默认为0，负数表示倒数的位置。 输出：一个布尔值。 注意：和indexOf的区别，indexOf进行了运算符的强比对，会导致对NaN误判。 举例 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 数组排序1.JavaScript的sort()方法123456var array = [1,4,-8,-3,6,12,9,8];function compare(val1,val2)&#123; return val1-val2;&#125;;array.sort(compare);document.write(array); sort()方法按照升序排列数组项，会调用每个数组项的toString()转型方法，然后比较得到的字符串。 toString()方法是把布尔值或BooleanObject转换为字符串，并返回结果。 compare()函数方法是一个比较函数，作为sort()方法的参数。 2. 冒泡排序（从后向前）123456789101112131415var array = [1,4,-8,-3,6,12,9,8];function sort(arr)&#123; for(var j=0;j&lt;arr.length-1;j++)&#123; //两两比较，如果前一个比后一个大，则交换位置。 for(var i=0;i&lt;arr.length-1-j;i++)&#123; if(arr[i]&gt;arr[i+1])&#123; var temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; &#125; &#125; &#125;&#125;sort(array);document.write(array); （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个位置。 （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 （3）针对所有的元素重复以上的步骤，除了最后一个。 （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 3. 快速排序：递归思想，两边快速的排序，冒泡排序的改进123456789101112131415161718192021222324var array = [1,4,-8,-3,6,12,9,8];function quickSort(arr)&#123;//如果数组长度小于等于1，则返回数组本身 if(arr.length&lt;=1)&#123; return arr; &#125; //定义中间值的索引 var index = Math.floor(arr.length/2); //取到中间值 var temp = arr.splice(index,1); //定义左右部分数组 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; //如果元素比中间值小，那么放在左边，否则放右边 if(arr[i]&lt;temp)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat(temp,quickSort(right));&#125;document.write(quickSort(array)); Math.floor(x)方法是向下取整，返回小于或等于x的最接近的整数。 splice(index,num,item)方法是向数组中添加项目，或是从数组中删除项目，并返回被删除的项目。 index是整数，被操作项目所在的位置（必须） num是整数，要删除的项目的数量，如果为0，表示不删除（必须） item是向数组中添加的新项目，可以是多个（可选） push()方法是向数组末尾添加一个或多个新项目并返回新数组的长度 concat()方法连接两个或多个数组，不会改变原有数组，返回一个新数组 4. 插入排序12345678910111213141516171819202122var array = [1,4,-8,-3,6,12,9,8];function insertSort(arr)&#123;//假设第0元素是有序序列，第1元素之后是无序的序列。从第1元素开始依次将无序序列的元素插入到有序序列中 for(var i=1; i&lt;arr.length;i++)&#123; if(arr[i]&lt;arr[i-1])&#123; //取出无序序列中需要插入的第i个元素 var temp = arr[i]; //定义有序中的最后一个位置 var j = i-1; arr[i] = arr[j]; //比较大小，找到插入的位置 while(j&gt;=0&amp;&amp;temp&lt;arr[j])&#123; arr[j+1] = arr[j]; j--; &#125;; //插入 arr[j+1] = temp; &#125; &#125; &#125;insertSort(array)document.write(array); （1）从第一个元素开始，该元素可以认为已经被排序（2）取出下一个元素，在已经排序的元素序列中扫描（3）如果该元素（已排序）大于新元素，将该元素移到下一位置（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置（5）将新元素插入到下一位置中（6）重复步骤2]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echart的相关设置]]></title>
    <url>%2F2018%2F02%2F28%2FechartSetting%2F</url>
    <content type="text"><![CDATA[整理一些能用到的echart设置 加入loading效果 12345678var myChart = echarts.init(document.getElementById(&apos;wsdBody&apos;));myChart.showLoading(&apos;default&apos;, &#123;text:&apos;统计中，请稍候...&apos;,maskColor: &apos;#404a59&apos;,textColor: &apos;#fff&apos;,&#125;); // hide setTimeout(function() &#123; myChart.hideLoading(); myChart.setOption(option); &#125;,500) echart图表重新绘制 123456789101112131415161718192021222324252627// 1.myChart.setOption(option,true);//true重绘// 2.//walden为echarts主题，_.flatten为underscore.js提供的数组扁平化方法var myChart = echarts.init(document.getElementById(&apos;main&apos;), &apos;walden&apos;);//封装_ajax方法，每次切换时发起get请求，获取相应的json文件，请求成功后渲染echartsfunction _ajax(url) &#123; $.ajax(&#123; type: &apos;get&apos;, url: url, success: function(res) &#123; option = &#123; xAxis: &#123; data: res.series &#125;, yAxis: &#123;&#125;, series: [&#123; name: &apos;销量&apos;, type: &apos;line&apos;, data: _.flatten(res.rows[0].values) &#125;] &#125;; myChart.setOption(option); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>echart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js date函数集合]]></title>
    <url>%2F2018%2F02%2F24%2Fdate%2F</url>
    <content type="text"><![CDATA[整理一些能用到的时间函数 获取当前时间123456789function getdate() &#123; var now = new Date(), y = now.getFullYear(), m = now.getMonth() + 1, d = now.getDate(); return y + &quot;-&quot; + (m &lt; 10 ? &quot;0&quot; + m : m) + &quot;-&quot; + (d &lt; 10 ? &quot;0&quot; + d : d) + &quot; &quot; + now.toTimeString().substr(0, 8);&#125;// 2018-02-27 10:50:49 获取日期 YY-MM-dd1234567891011121314151617function getNowFormatDate() &#123; var date = new Date(); var seperator1 = &quot;-&quot;; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = &quot;0&quot; + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = &quot;0&quot; + strDate; &#125; var currentdate = year + seperator1 + month + seperator1 + strDate; $(&apos;#end_time&apos;).val(currentdate); $(&apos;#start_time&apos;).val(beforedate)&#125;getNowFormatDate(); 获取时间-日期1234567891011121314151617181920212223242526272829303132333435function showTime()&#123; var date = new Date(); var year = date.getFullYear(); var mouths = date.getMonth()+1; if (mouths &lt; 10) &#123; mouths = &apos;0&apos; + mouths; &#125; var day = date.getDate(); if (day &lt; 10) &#123; day = &apos;0&apos; + day; &#125; var hours = date.getHours(); if (hours &lt; 10) &#123; hours = &apos;0&apos; + hours; &#125; var minutes = date.getMinutes(); if (minutes &lt; 10) &#123; minutes = &apos;0&apos; + minutes; &#125; var seconds = date.getSeconds(); if (seconds &lt; 10) &#123; seconds = &apos;0&apos; + seconds; &#125; var weekDay = new Array(7); weekDay[0] = &quot;星期日&quot;; weekDay[1] = &quot;星期一&quot;; weekDay[2] = &quot;星期二&quot;; weekDay[3] = &quot;星期三&quot;; weekDay[4] = &quot;星期四&quot;; weekDay[5] = &quot;星期五&quot;; weekDay[6] = &quot;星期六&quot;; document.getElementById(&quot;newTime&quot;).innerHTML=year+&quot;年&quot;+mouths+&quot;月&quot;+day+&quot;日&quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds+&quot; &quot;+weekDay[date.getDay()];&#125;setInterval(&quot;showTime();&quot;,1000); JS 求时间差var date1=new Date(); //开始时间alert(“aa”);var date2=new Date(); //结束时间var date3=date2.getTime()-date1.getTime() //时间差的毫秒数 //计算出相差天数var days=Math.floor(date3/(2436001000)) //计算出小时数 var leave1=date3%(2436001000) //计算天数后剩余的毫秒数var hours=Math.floor(leave1/(36001000))//计算相差分钟数var leave2=leave1%(36001000) //计算小时数后剩余的毫秒数var minutes=Math.floor(leave2/(60*1000)) //计算相差秒数var leave3=leave2%(60*1000) //计算分钟数后剩余的毫秒数var seconds=Math.round(leave3/1000) alert(“ 相差 “+days+”天 “+hours+”小时 “+minutes+” 分钟”+seconds+” 秒”)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markedown 语法简介]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[css的使用 文本溢出td1234567891011table&#123; width:100px; table-layout:fixed;/* 只有定义了表格的布局算法为fixed，下面td的定义才能起作用。 */ &#125; td&#123; width:100%; word-break:keep-all;/* 不换行 */ white-space:nowrap;/* 不换行 */ overflow:hidden;/* 内容超出宽度时隐藏超出部分的内容 */ text-overflow:ellipsis;/* 当对象内文本溢出时显示省略标记(...) ；需与overflow:hidden;一起使用*/ &#125; 单行12345678910overflow: hidden;text-overflow:ellipsis;white-space: nowrap;// 多行display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 适用于WebKit浏览器及移动端1234567p&#123;position: relative; line-height: 20px; max-height: 40px;overflow: hidden;&#125;p::after&#123;content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px;background: -webkit-linear-gradient(left, transparent, #fff 55%);background: -o-linear-gradient(right, transparent, #fff 55%);background: -moz-linear-gradient(right, transparent, #fff 55%);background: linear-gradient(to right, transparent, #fff 55%);&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markedown 语法简介]]></title>
    <url>%2F2018%2F01%2F24%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[标题 在行首插入1-6个#、分别对应1-6级标题 1# 我是标题 引言 在段落的第一行前面加入&gt; 这是引用别人的话 1234567891011121314151617181920212223242526 &gt; 这是引用别人的话 ``` ### 换行、分段 &amp;ensp;&amp;ensp;换行：行末加两个或以上个空格 &amp;emsp;&amp;emsp;分段：两个回车 ### 加入有序列表和无序列表&gt; 无序列表 * + -都可以生成 * red * blue &gt; 有序列表 1.加空格 1. red 2. blue ### 链接 [参考链接](http://www.baidu.com/ &quot;百度&quot;) 找问题 ` [参考链接](http://www.baidu.com/ &quot;百度&quot;) 找问题`### 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： single asterisks single underscores double asterisks double underscores 12345678910111213 *single asterisks* _single underscores_ **double asterisks** __double underscores__### 图片图片的语法和链接很像。行内形式(title 是选择性的): 12345678910### 链接More info: [Deployment](https://hexo.io/docs/deployment.html)参考形式：![alt text][id][id]: https://img-blog.csdn.net/20161222085404804 &quot;Title&quot;上面两种方法都会输出 HTML 为： ` 其他 分割线 ***]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期]]></title>
    <url>%2F2017%2F08%2F24%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Vue2.0 探索之路——生命周期和钩子函数的一些理解 生命周期钩子 详细 beforeCreate 在实例初始化之后，数据观测(data observer)和event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。 activated keep-alive 组件激活时调用。 deactivated keep-alive 组件停用时调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 测试过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;keep-alive&gt; &lt;my-components msg=&quot;hello&quot; v-if=&quot;show&quot;&gt;&lt;/my-components&gt; &lt;/keep-alive&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var child = &#123; template: &apos;&lt;div&gt;from child: &#123;&#123;msg&#125;&#125;&lt;/div&gt;&apos;, props: [&apos;msg&apos;], data: function () &#123; return &#123; childMsg: &apos;child&apos; &#125;; &#125;, deactivated: function () &#123; console.log(&apos;component deactivated!&apos;); &#125;, activated: function () &#123; console.log(&apos;component activated&apos;); &#125; &#125;; var app = new Vue(&#123; el: &apos;#app&apos;, data: function () &#123; return &#123; message: &apos;father&apos;, show: true &#125;; &#125;, beforeCreate: function () &#123; console.group(&apos;beforeCreate 创建前状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(state); &#125;, created: function () &#123; console.group(&apos;created 创建完毕状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(state); &#125;, beforeMount: function () &#123; console.group(&apos;beforeMount 挂载前状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(this.$el); console.log(state); &#125;, mounted: function () &#123; console.group(&apos;mounted 挂载结束状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(this.$el); console.log(state); // this.message = &apos;change&apos;; &#125;, beforeUpdate: function () &#123; console.group(&apos;beforeUpdate 更新前状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(this.$el); console.log(state); // this.message = &apos;change2&apos;; &#125;, updated: function () &#123; console.group(&apos;updated 更新完成状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(this.$el); console.log(state); &#125;, beforeDestroy: function () &#123; console.group(&apos;beforeDestroy 销毁前状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(this.$el); console.log(state); &#125;, destroyed: function () &#123; console.group(&apos;destroyed 销毁完成状态===============》&apos;); var state = &#123; &apos;el&apos;: this.$el, &apos;data&apos;: this.$data, &apos;message&apos;: this.message &#125; console.log(this.$el); console.log(state); &#125;, components: &#123; &apos;my-components&apos;: child &#125; &#125;);&lt;/script&gt;&lt;/html&gt; ###create 和 mounted 相关 1234beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 应用1234beforecreate : 举个栗子：可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 在created钩子中可以对data数据进行操作，这个时候可以进行ajax请求将返回的数据赋给data 在mounted钩子对挂载的dom进行操作 在使用vue-router时有时需要使用来缓存组件状态，这个时候created钩子就不会被重复调用了，如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex的基本使用]]></title>
    <url>%2F2017%2F08%2F24%2FVuex%2F</url>
    <content type="text"><![CDATA[举个栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;app&quot;&gt; &lt;div&gt;我现在有&#123;&#123;nowcount&#125;&#125;条数&lt;/div&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;reduce&quot;&gt;reduce&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; add(state, count) &#123; state.count += count; &#125;, REDUCE(state, count) &#123; state.count += count &#125; &#125;, actions: &#123; reduce(context, count) &#123; context.commit(&apos;REDUCE&apos;, count) &#125;, add(context, count) &#123; context.commit(&apos;add&apos;,count) &#125; &#125; &#125;) var app = new Vue(&#123; el: &apos;.app&apos;, store: store, data() &#123; &#125;, computed: &#123; nowcount() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; add() &#123; // this.$store.commit(&apos;add&apos;, 5) this.$store.dispatch(&apos;add&apos;,5) &#125;, reduce() &#123; this.$store.dispatch(&apos;reduce&apos;, -5) &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 通过computed的计算属性直接赋值computed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。 12345computed: &#123; nowcount() &#123; return this.$store.state.count &#125;&#125;, 通过mapState的对象来赋值1computed:mapState([&quot;count&quot;]) 通过mutations修改状态（$store.commit( )）1234add() &#123; // this.$store.commit(&apos;add&apos;, 5) this.$store.dispatch(&apos;add&apos;,5)&#125;, 通过脚手架获取Mutations方法12345678import &#123; mapState,mapMutations &#125; from &apos;vuex&apos; methods: &#123; ...mapMutations(&#123; add, reduce: &apos;REDUCE&apos; &#125;) &#125; 通过actions异步修改状态actions和之前讲的Mutations功能基本一样，不同点是，actions是异步的改变state状态，而Mutations是同步改变状态。 在store.js中声明actions123456reduce(context, count) &#123; context.commit(&apos;REDUCE&apos;, count)&#125;,add(&#123;commit&#125;, count) &#123; commit(&apos;add&apos;,count)&#125; 在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。 context：上下文对象，这里你可以理解称store本身。 {commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。 在脚手架中的使用12345678import &#123;mapActions&#125; form &apos;mapActions&apos;methods:&#123; ...mapMutations([ &apos;add&apos;,&apos;reduce&apos; ]), ...mapActions([&apos;add&apos;,&apos;reduce&apos;])&#125;,]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router 的相关]]></title>
    <url>%2F2017%2F08%2F24%2Fvue-router%2F</url>
    <content type="text"><![CDATA[$route 和 $router的区别？ $router 是router（路由）实例；$route 是一个对象，可以访问path，name等属性。还有就是route object 是只读的，不可变的，所以我们不能更改其中的值。 $route.params 和 $roue.query 的区别？1234567891011// 1.显示的方式不一样// $route.params url显示 /user/123 // $route.query url显示 /user/id=123 // 在router-link中显示形态&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;router-link :to=&#123;name:&apos;a&apos;, params:&#123;id:123&#125;&#125;&gt;&lt;/router-link&gt;// 如果使用 params 就不能写 path 路径（写了也访问不到），可以配置name来匹配路径 路由懒加载112345678910111213141516//懒加载路由 const routes = [ &#123; //当首次进入页面时，页面没有显示任何组件；让页面一加载进来就默认显示first页面 path:&apos;/&apos;, //重定向，就是给它重新指定一个方向，加载一个组件； component:resolve =&gt; require([&apos;@/components/First&apos;],resolve) &#125;, &#123; path:&apos;/first&apos;, component:resolve =&gt; require([&apos;@/components/First&apos;],resolve) &#125;, &#123; path:&apos;/second&apos;, component: resolve =&gt; require([&apos;@/components/Second&apos;],resolve) &#125; //这里require组件路径根据自己的配置引入 ] 21234567891011121314151617181920import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router)const Recommend = (resolve) =&gt; &#123; import(&apos;components/recommend/recommend&apos;).then((module) =&gt; &#123; resolve(module) &#125;)&#125;export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/recommend&apos; &#125;, &#123; path: &apos;/recommend &#125;] &#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS的基本操作]]></title>
    <url>%2F2017%2F04%2F17%2F%E5%8E%9F%E7%94%9FJS%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[原生JS的基本操作 创建和获取元素创建123456var para=document.createElement(&quot;p&quot;);var node=document.createTextNode(&quot;这是一个新段落。&quot;);需要被复制的节点.cloneNode(true/false)true复制当前节点极其所以子节点，false仅复制当前节点 获取元素与节点元素 通过ID获取（getElementById） 通过name属性（getElementsByName） 通过标签名（getElementsByTagName） 通过类名（getElementsByClassName） 获取html的方法（document.documentElement） 获取body的方法（document.body） 通过选择器获取一个元素（querySelector） 通过选择器获取一组元素（querySelectorAll） 节点父节点 parentNode ：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment parentElement ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null 兄弟关系型 previousSibling ：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下 previousElementSibling ：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持 nextSibling ：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下 nextElementSibling ：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持 子节点 childNodes ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等 children ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持； firstChild ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild lastChild ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild 节点修改123456parent.appendChild(child); //它会将child追加到parent的子节点的最后面parentNode.insertBefore(newNode, refNode); //将某个节点插入到另外一个节点的前面parent.removeChild(node); //用于删除指定的子节点并返回子节点parent.replaceChild(newChild, oldChild); //用于将一个节点替换另一个节点 获取元素的属性，设置元素的属性，删除123设置属性 .setAttribute(&quot;属性&quot;,&quot;值&quot;)获取属性 .getAttribute(&quot;属性&quot;)删除属性 .removeAttribute(&quot;属性&quot;) 获取元素尺寸123456789101112131415网页可见区域宽： document.documentElement.clientWidth;网页可见区域高： document.documentElement.clientHeight; 网页正文全文宽： document.documentElement.scrollWidth;网页正文全文高： document.documentElement.scrollHeight;网页被卷去的高(ff)：document.body.scrollTop; 网页被卷去的高(ie): document.documentElement.scrollTop; 网页被卷去的左：document.body.scrollLeft; 网页正文部分上：window.screenTop; 网页正文部分左：window.screenLeft; 某个元素的宽度：obj.offsetWidth;某个元素的高度：obj.offsetHeight;某个元素的上边界到body最顶部的距离：obj.offsetTop;（在元素的包含元素不含滚动条的情况下）某个元素的左边界到body最左边的距离：obj.offsetLeft;（在元素的包含元素不含滚动条的情况下）返回当前元素的上边界到它的包含元素的上边界的偏移量：obj.offsetTop（在元素的包含元素含滚动条的情况下）返回当前元素的左边界到它的包含元素的左边界的偏移量：obj.offsetLeft（在元素的包含元素含滚动条的情况下）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于点击空白关闭弹窗的js写法推荐]]></title>
    <url>%2F2017%2F03%2F14%2FclickCancel%2F</url>
    <content type="text"><![CDATA[关于点击空白关闭弹窗的js写法推荐123456789101112131415161718192021222324// menuvar open_menu = true;$(&quot;#arrow-right&quot;).on(&quot;click&quot;, function(e)&#123; if (open_menu) &#123; $(&quot;#left_nav&quot;).show(); $(&apos;#logo-img&apos;).addClass(&apos;open&apos;) open_menu = false $(document).one(&quot;click&quot;, function()&#123; $(&quot;#left_nav&quot;).hide(); $(&apos;#logo-img&apos;).removeClass(&apos;open&apos;) open_menu = true &#125;); e.stopPropagation(); &#125; else &#123; $(&quot;#left_nav&quot;).hide(); $(&apos;#logo-img&apos;).removeClass(&apos;open&apos;) open_menu = true &#125;&#125;);$(&quot;#left_nav&quot;).on(&quot;click&quot;, function(e)&#123; $(&apos;#logo-img&apos;).removeClass(&apos;open&apos;) e.stopPropagation();&#125;);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
